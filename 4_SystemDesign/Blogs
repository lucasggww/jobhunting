1. Computer science Foundation.
    Basics.
    Pros and Cons
    Complexity
    Comparision.
2. How to prepare Google Interview Questions.
    Chapter 3: Prepare coding, prepare it smartley and use less time.
        Why prepare? Because most engineers use just arrays, they seldom use stack, queue.
        The point is not expecting same question, but is to getting familiar with similar questions.
        80/20 rules said 80% output comes from 20% causes.
        Tip 1: Write down solid codes. Coming right thoughts is not even half of done.
        Tip 2: Think out loud. Show your communication skill, Interview will correct you if you are not on the right track,
            clear your mind before the idea is concrete.
        Tip 3: Track your time. 45 minutes interview. Introduction, ask questions, only 35 minutes to finish two coding questions.
        Tip 4: Go back to basic foundations: linked list, recursion, dynamic programming,
        Build solid foundation, think loud, practice and track your time.
    Chapter 4: Experience engineers, interns and fresh graduates.
        How to prepare? Data structure, algorithm and testing
        Usually new grads outperforms experienced engineers in coding questions.
        Coding questions is different with project experience.
        Amazing job and relevant to current position.
        Different stories for different companies and for different jobs.
        Shorter timeline, squeeze your time into short time zone.
        Consistent, take 2-3 hours a day, compress the preparation time.
    Chapter 5: System design.
        System design is open topic, it's a communication between you and the interviewer.
        Eg. "Design a web-crawler", focus on overall crawler design, how to detect contents is changed,
        how to dedup the URLs in detail.

        Measure your capability and improve it.
        1. Check if it works. 2. check feasibility.  How much efferts do you need to implement it?
        People and time. 3. Design should be clear. why design so ?
        2. Do not focus on tools usage, but on how do they design, how do they work?
            Like distribute workload, aggregate data later,etc.
            